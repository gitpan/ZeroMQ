# Do NOT edit this file! This file was automatically generated
# by Makefile.PL on Fri Aug 20 22:00:23 2010. If you want to
# regenerate it, remove this file and re-run Makefile.PL

TYPEMAP

PerlZMQ_Context* T_PERLZMQ_CONTEXT
PerlZMQ_Socket* T_PERLZMQ_SOCKET
PerlZMQ_Message* T_PERLZMQ_MESSAGE


INPUT

T_PERLZMQ_CONTEXT
    {
        MAGIC *mg;
        $var = NULL;
        if (sv_isobject($arg)) {
            mg = PerlZMQ_Context_mg_find(aTHX_ SvRV($arg), &PerlZMQ_Context_vtbl);
            if (mg) {
                $var = (PerlZMQ_Context *) mg->mg_ptr;
            }
        }

        if ($var == NULL)
            croak(\"Invalid ZeroMQ::Context object (perhaps you've already closed it?)\");
    }

T_PERLZMQ_SOCKET
    {
        MAGIC *mg;
        $var = NULL;
        if (sv_isobject($arg)) {
            mg = PerlZMQ_Socket_mg_find(aTHX_ SvRV($arg), &PerlZMQ_Socket_vtbl);
            if (mg) {
                $var = (PerlZMQ_Socket *) mg->mg_ptr;
            }
        }

        if ($var == NULL)
            croak(\"Invalid ZeroMQ::Socket object (perhaps you've already closed it?)\");
    }

T_PERLZMQ_MESSAGE
    {
        MAGIC *mg;
        $var = NULL;
        if (sv_isobject($arg)) {
            mg = PerlZMQ_Message_mg_find(aTHX_ SvRV($arg), &PerlZMQ_Message_vtbl);
            if (mg) {
                $var = (PerlZMQ_Message *) mg->mg_ptr;
            }
        }

        if ($var == NULL)
            croak(\"Invalid ZeroMQ::Message object (perhaps you've already closed it?)\");
    }



OUTPUT

T_PERLZMQ_CONTEXT
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZeroMQ::Context\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlZMQ_Context_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }

T_PERLZMQ_SOCKET
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZeroMQ::Socket\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlZMQ_Socket_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }

T_PERLZMQ_MESSAGE
        if (!$var)          /* if null */
            SvOK_off($arg); /* then return as undef instead of reaf to undef */
        else {
            /* setup $arg as a ref to a blessed hash hv */
            MAGIC *mg;
            HV *hv = newHV();
            const char *classname = \"ZeroMQ::Message\";
            /* take (sub)class name to use from class_sv if appropriate */
            if (SvMAGICAL(class_sv))
                mg_get(class_sv);

            if (SvOK( class_sv ) && sv_derived_from(class_sv, classname ) ) {
                if(SvROK(class_sv) && SvOBJECT(SvRV(class_sv))) {
                    classname = sv_reftype(SvRV(class_sv), TRUE);
                } else {
                    classname = SvPV_nolen(class_sv);
                }
            }

            sv_setsv($arg, sv_2mortal(newRV_noinc((SV*)hv)));
            (void)sv_bless($arg, gv_stashpv(classname, TRUE));
            mg = sv_magicext((SV*)hv, NULL, PERL_MAGIC_ext, &PerlZMQ_Message_vtbl, (char*) $var, 0);
            mg->mg_flags |= MGf_DUP;
        }


